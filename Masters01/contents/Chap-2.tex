% !TeX spellcheck = en_GB
\chapter{Literature Review}
\label{chp:LR}
As mentioned in Section \ref{sec:intro_bg}, \ac{cpp} is a subset of the general motion planning problem. This chapter will therefore begin with a brief overview of motion planning before discussing \ac{cpp} as a whole. Literature pertaining to \ac{cpp} is then discussed in several sections. Firstly, it is addressed in the context of the single robot \ac{cpp} problem. Several techniques used to achieve coverage using only one robot are summarized. 

Following this are three sections dedicated to the \ac{mcpp} problem. The first two cover distributed and non-distributed offline \ac{mcpp} respectively. This is followed by a section presenting some online \ac{mcpp} implementations. Many of the implementations were done with some application in mind, but the last section covers \acp{uav} and how they have been applied to \ac{sar} operations in particular. 

\section{Motion Planning}
\label{sec:LR-Motion Planning}
% TODO: Maybe make this section a bit shorter
One of the most noteworthy items of literature presented on motion planning is by Lavalle \cite{Lavalle2006}. In this book, a differentiation is made between motion planning and trajectory planning. Motion planning, by their definition, refers to a series of translations and/or rotations required to get an agent from one point to another within some environment. Trajectory planning would then take this plan and find a strategy to execute it within the dynamic constraints of the agent. 

\emph{Agent} is a term from the field of artificial intelligence and is interchangeable with \emph{robot} or \emph{decision maker}. The agent will be what executes the plan once it is determined. Overall, a planning algorithm is used to develop a plan for the agent to execute within an environment. Execution generally refers to a real-world implementation of a plan on some device, for example, a \ac{uav}. It can also be performed in simulation. \cite{Lavalle2006}

The type of task that is executed as well as the environment it will be executed in are important for deciding on a motion planning algorithm.  The environment may be described as discrete or continuous. Some applications, such as solving a Rubik's cube, can be represented in a discrete manner \cite{Lavalle2006}. Most robotics applications, however, are in a continuous environment, which adds a layer of complexity to problem \cite{AIbook}.

Lavalle classifies motion planning problems into discrete and continuous. He discusses point-to-point path planning algorithms such as A* and Dijkstra's Algorithm in the context of discrete path planning. He then classifies continuous problems into two major categories, namely combinatorial and sampling-based methods.

The key difference between these methods is that combinatorial methods explicitly describe the environment, including obstacles, prior to searching and guarantee completeness. Sampling-based methods are generally resolution complete or probabilistically complete, which are more lax notions of completeness. Sampling-based methods sample points in the environment and tend to perform incremental collision avoidance during pathfinding. \cite{Lavalle2006}

The notion of completeness refers to the ability of a planning algorithm to correctly find a solution if one exists, otherwise reporting that there is no solution. Resolution completeness simply guarantees completeness only down to a certain resolution, and probabilistic completeness means that the probability of reporting a correct solution converges to one. \cite{Lavalle2006}

Sampling based methods are often better at dealing with a dynamic environment, whereas combinatorial methods, also known as exact methods, require exact knowledge of the environment beforehand and cannot handle dynamic obstacles without replanning, which is very inefficient. \ac{rrt} and \ac{prm} are respective examples of single and multi-query sampling-based methods. Combinatorial methods utilize methods like trapezoidal decompositions and Voronoi diagrams to generate roadmaps. Roadmaps in general can easily be navigated using discrete methods like A*. \cite{Lavalle2006}

Whenever developing a plan, the task could be to move from one point to another, change orientation, or to cover every point within an environment. The task could also involve multiple agents. Optimizing paths in these scenarios can be quite challenging because agents must now not only avoid collisions with obstacles in the environment, but also with one-another, while trying to achieve a certain goal. In the context of path planning with \acp{uav}, the nature of the goal makes the problem fall into different categories, according to the authors of \cite{Zhang2020}. 

In a point-to-point problem, if the goal location is the same for all \acp{uav}, it is referred to as a rendezvous task. If they all have different goal locations, it is an allocation task. And lastly, if the goal is not to move from a starting position to a goal, but instead to cover every point in an environment, it is called a coverage task. This classification is highlighted in Figure \ref{fig:MotionPlanning}.

One final concept to grasp for motion planning, is the difference between online and offline planners. Offline algorithms draw a distinct line between the planning phase and the execution phase. The entire plan is already developed prior to real-world (or simulation based) execution, since the environment is known. Online planners tend to perform planning and execution in tandem. Generally, the environment is sensed as the agent moves and the plan is computed as it goes. The environment is either not known a priori, or is too costly to give as an input for the application. \cite{AIbook}
\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth,trim={7cm 8.5cm 6.5cm 1.5cm},clip]{figs/Motion.pdf} % L  R
\caption{Flow diagram showing a breakdown of the different kinds of path planning as part of motion planning.}
\label{fig:MotionPlanning}
\end{figure}
\section{Coverage Path Planning}
\label{sec:LR-CPP}
% What is coverage path planning
\ac{cpp} is a subset of the general motion planning problem. The coverage task refers to visiting all points within an environment as opposed to the general start-goal type task \cite{Zhang2020}. \ac{cpp} can fall into the same categories as motion planning. It can be classified as discrete or continuous, online or offline, and as a single or multiple agent problem.

% 2001 Survey
A number of surveys have been done to give an overview of the literature available and progress made in the field of \ac{cpp}. A survey was done in 2001 wherein Choset divides \ac{cpp} into four categories \cite{Choset2001}. In later papers this is known as Choset's taxonomy, and is widely used to describe different types of \ac{cpp} algorithms.

Choset addresses heuristic and/or randomized approaches and also looks at three type of cellular decompositions, namely approximate, semi-approximate and exact. He continues in briefly addressing the multi robot scenario. The cellular decompositions all rely on simplifying the environment to achieve provably complete coverage. 

% TODO: STC is an approximate method. maybe reference the section that discusses that, along with other approximate methods
The approximate methods mean the environment is modelled as a set of cells with equal size and shape, generally a grid. These algorithms can achieve complete coverage of the discrete approximation of the environment, but don't guarantee complete coverage for the actual environment. Exact cellular decompositions divide the environment into polygons and cover these using simple motions e.g. back-and-forth manoeuvres. This can achieve complete coverage of the actual environment, hence the term \emph{exact}. This is further discussed in Section \ref{sec:LR - sExact}. 

% 2013 and 2019 Survey
In 2013, a survey was done regarding \ac{cpp} in robotics \cite{CPP-Survey-2013}. It expands on Choset's taxonomy and gives more detail on recent developments in each category. This paper also addresses \ac{cpp} in three-dimensional scenarios, and briefly looks at \ac{cpp} where \ac{slam} is applied due to localization uncertainties. 
% TODO: make sure you write 2D an 3D the same everywhere e.g two-dimensional
Another recent survey was published in 2019, that once again builds on Choset's taxonomy \cite{CPP-Survey-2019}. They spend more time discussing simple manoeuvres and contrast them with more complex solutions.

% 2020 Survey - multiple robots
Generally multi-robot approaches add a layer of complexity to \ac{cpp}. The most notable challenge that arises is collision avoidance. Robots need to cooperate to achieve coverage while not only avoiding collisions with obstacles, but also with each other. In 2020, a paper was compiled that specifically deals with cooperative path planning \cite{Zhang2020}. It surveys path planning with multiple \acp{uav} for the purpose of achieving many different goals, coverage being one of them.
%TODO: make sure you dont hyphenate cooperative anywhere

% TODO: Should you mention Centralized vs Decentralized (2020 paper looks at that in more detail)

% Description of offline vs online and mention that the next sections are offline, offline and online
In this chapter, a number of \ac{cpp} techniques are explored. Methods using a single robot for coverage are discussed in Section \ref{sec:LR sCPP}. Sections \ref{sec:LR Ditributed MCPP} and \ref{sec:LR Non-Distributed MCPP} refer to offline methods of \ac{mcpp} and Section \ref{sec:LR Online MCPP} looks at online methods. The sections that discuss offline methods are categorised as distributed and non-distributed.

% Definition of distributed
Distributed, for the purpose of this paper, refers to methods where the paths of individual \acp{uav} do not overlap. They are expected to fly in their own isolated sub-regions within an environment. In non-distributed methods,\acsp{uav} are free to cross paths. The area division step is not performed and so their paths are simply computed simultaneously, with knowledge of which cells have already been visited. \cite{Juan2018}

\section{Single Robot Coverage Path Planning}
\label{sec:LR sCPP}
Single robot coverage is discussed in some detail here because several of the \ac{mcpp} problems make use of them. Distributed problems tend to divide an environment into sub-regions that can then be covered using single robot techniques. Several of the other methods simply use the single robot methods and scale them to multiple robot applications. The subsections discuss several existing planning algorithms. This is by no means a comprehensive list of all the algorithms available, but gives a brief overview of varying techniques.%TODO: Subsection breakdown
% Mention simple maneouvres
\subsection{Exact Methods}
\label{sec:LR - sExact}
Combinatorial methods, as described by Lavalle, are also referred to as exact methods \cite{Lavalle2006}. Exact methods for \ac{cpp} make use of the same geometric principles to divide an area into cells. However, instead of creating a roadmap, an adjacency graph is created and used to move between cells. Each cell is then individually covered, generally using simple manoeuvres \cite{CPP-Survey-2013}. 

Each cell in the decomposition is a node in the adjacency graph. An exhaustive walk is used to ascertain the sequence in which to visit these nodes to achieve coverage. Simple manoeuvres, such as back-and-forth motions, are then used to cover each cell individually. These algorithms are complete, so will completely cover the environment when possible. \cite{Choset-Bous1997}

A popular method, that is mentioned in Lavalle's book, is the trapezoidal decomposition. This method decomposes an environment into trapezoids (convex cells) based on the vertices of polygonal obstacles \cite{Lavalle2006}.

The trapezoidal and boustrophedon decomposition methods are applicable in two-dimensional coverage problems. They are offline approaches, since the environment must be known a priori, and only operate with polygonal obstacles. The boustrophedon method reduces the number of cells by only looking at vertices where a line can extend both upwards and downward from it. This reduces the final length of the coverage path and makes it more efficient. \cite{CPP-Survey-2013} 
% Some simplifications of the environment are probably made to make it polygonal. The lower poly it is, the more approximate the method can become. Still more accurate than grid based though.

A more versatile exact method, that uses Morse functions for the decomposition, is also available \cite{Choset-Morse2000}. This no longer requires polygonal environments and can in theory be expanded to higher dimensional environments.

One paper sought to optimize exact cellular decomposition somewhat. This is also applied in polygonal environments. They use a greedy recursive technique to preform the decomposition and optimize the sweep direction to reduce the number of rotations. For their application, they proved that one can reduce energy consumption and the coverage route length, and thereby the time to complete coverage, by minimising rotations. \cite{Li2011}
\subsection{Sampling-Based Methods}
\label{sec:LR - sSampling}
Sampling-based methods have been adapted for coverage path planning. They are more easily scaled to three dimensional environments and are better suited to online or real-time approaches. They also deal with changing environments with dynamic obstacles more easily. \cite{Lavalle2006}

\ac{rrt} has been adapted to \ac{cpp}. An example of this is an application involving automated lawn mowing. They used \ac{rrt} as a local planner in combination with a global planner that uses a spiral motion to cover the points in a map. A solution is however, not guaranteed. Complete coverage is also not necessarily achieved because of the random nature of the paths, but it is considered a real-time approach. \cite{Nourani-Vatani2006}

Two other problems, that are both proven to be probabilistically complete, are the watchman route algorithm and the redundant roadmap algorithm \cite{Englot2012}. The watchman method constructs a roadmap, and coverage is achieved using a minimum spanning tree. Roadmap construction is generally done using a \ac{prm} \cite{Danner2000}.% Watchmen method

The redundant roadmap method also constructs a roadmap and then conducts local point-to-point planning using \ac{rrt}, which also encompasses collision avoidance \cite{Englot2011}. 

An example of an online algorithm takes \ac{prm} and \ac{rrt} and combines them into a single point-to-point path planner, which includes dynamic replanning capabilities \cite{Wzorek2006}. These authors later expanded this to a coverage solution involving back and forth manoeuvres \cite{Rudol2008}. This is discussed in more detail in Section \ref{sec:LR SAR-Sampling}.
\subsection{A* and Wavefront Based Coverage}
\label{sec:LR - sA*}
This is a discrete method of planning. As mentioned in Section \ref{sec:LR-Motion Planning}, A* is often used in point-to-point path planning. In combinatorial motion planning or multiple-query sampling-based methods such as \ac{prm}, roadmaps are generally formed to represent the environment. These roadmaps can then be navigated using A* or another discrete algorithm like Dijkstra's algorithm or a forward search. \cite{Lavalle2006}.

A* was built from Dijkstra's algorithm, which is like a forward search that takes cost into account for the priority queue. A* is an extension of this that also predicts the cost to reach the goal using a heuristic. 

Dijkstra has also been optimised into what is called a wavefront planner. With this technique, equal cost points are grouped together into "waves" and the algorithm essentially propagates out in waves until it reaches the goal \cite{Lavalle2006}. This wavefront type planning has also been used for \ac{cpp}, with the goal to minimise rotations and the number of revisited cells \cite{Barrientos2011}.

Some authors have taken to extending A* algorithms to \ac{cpp} as well. Here the environment is generally divided into a grid and the cells can represent obstacles or free space. The starting and end-points are always within free space cells.

One of the earlier interpretations of A* \ac{cpp} is a combination of the boustrophedon method described in \ref{sec:LR - sExact} and A* \cite{Viet2012}. This is an online method that constructs boustrophedon regions incrementally and uses A* to move from one region to the next. 

In point-to-point path planning, the goal is usually to achieve the shortest path possible and the heuristic function is set up for that purpose. For \ac{cpp}, the cost function is changed to maximize coverage instead. One such implementation uses A* in a grid-based, offline approach where they try to minimise the amount of cells that get revisited \cite{Le2018}. They use critical waypoints and A* based zigzag motions. 

Another implementation uses a heuristic function with the goal of minimising the number of rotations, as was the goal of the wavefront planner mentioned earlier in this section \cite{Dogru2017}. This is useful, because rotations often consume more energy than straight line motions.
\subsection{Spanning Tree Coverage}
\label{sec: LR - sSTC}
Spanning trees are a applied in discrete environments. They can be applied in an offline scenarios or incrementally grown for online applications \cite{Gabriely2001}. A spanning tree is created to reach all nodes in an environment. To make a path efficient, the spanning tree is generally used on nodes that represent the centres of larger cells. 

These larger cells are then divided into four smaller cells each, which can then be the cells that are navigated by the agents. To reach each cell, the algorithm simply circumnavigates the tree. When operating in a continuous environment, the environment must be divided into the larger cells. A nice feature that this method provides is that it forms a closed loop path. The agent will always loop back to its starting point. \cite{Hazon2005} 

The spanning trees used are usually minimum spanning trees, constructed using algorithms such as Prim's algorithm. These algorithms can minimise tree weight. This weight can represent distance, or any number of other costs. They can even be used to reduce rotations by encouraging the robot to scan an area along a particular direction. \cite{Gabriely2001}

\subsection{Artificial Intelligence Methods}
\label{sec:LR - sAI}
One article compared several \ac{ai} techniques for \ac{cpp}. Four methods were compared, including one that employs a \ac{ga}. The four methods are the La Palma attraction, La Palma fuzzy logic, \ac{anfis} and \ac{pso} approaches. \cite{Juan2018}

All of the methods were implemented in a discretized environment (a grid). In this paper they also generate what they call a \emph{Risk/Occupancy Map}. This is given as an input for their algorithms to encourage searching of certain areas first. For each cell, they generate a potential risk/occupancy value ($P$). The higher the value, the higher the priority of searching that cell.

They evaluated performance of these algorithms in the context of search and rescue and found that the \ac{anfis} approach gives the best performance for that application. The attraction method works well for environments with maps that don't have a varying $P$ value. Fuzzy logic works well when a big portion of the map has high $P$ values, but has a lower success rate. \ac{pso} was shown to not work well at all.


\section{Distributed Offline MCPP}
\label{sec:LR Ditributed MCPP}
A well established offline coverage path planning approach involves the divide areas technique. This partitions an area into regions for individual robots to cover. Each robot should then be able to cover its area using one of the individual area coverage techniques mentioned in Section \ref{sec:LR sCPP}. The subsections are divided into different implementations, sorted according to the area division step in the planning process. The methods used to perform coverage of the sub-regions are mentioned in each section seen as these are important in generating the final coverage plan.
%TODO: Distributed vs Non-distributed - give the definition for the purpose of this paper
\subsection{Hexagonal Segmentation}
\label{sec:LR-Hex}
A notable distributed approach uses regular hexagons to segment the area of interest \cite{Azpurua2018}. This implementation is reminiscent of the exact methods often used for single robot coverage path planning mentioned in Section \ref{sec:LR - sExact}. Exact methods generally divide an area into arbitrarily sized polygons called cells. The robot moves between these cells and covers them using simple motions. In the multi-robot scenario, the area is still divided into cells, but they need to be distributed between the robots evenly for searching. The ideal situation is to assign equal sized areas to each robot so that their path lengths are similar and they can complete their paths at roughly the same time.\\
Hexagonal cells make it easier to assign cells to robots, seen as they are all of the same size. Hexagons are clustered using the K-means algorithm to ensure a similar number of cells are assigned to each robot. The seeds are synonymous with the robots, therefore once the seed locations are finalized for even cell distribution, the robot initial positions are established. The robots cannot start from any random location, which can be undesirable. \\
The hexagons that are assigned to a given robot are contiguous and form a sub-region that is then covered using simple manoeuvres. Back and forth motions are generally quite popular. Static obstacles are considered in this implementation, but the smallest obstacle resolution is the size of a hexagon which may not be very representative of the environment. Figure \ref{fig:Hex}, taken directly from their paper, illustrates the back and forth manoeuvres used to cover the hexagonal partitions. Black hexagons represent no-fly zones and/or static obstacles. The dark red, green and blue regions represent the sub-regions as they are assigned to the respective robots for coverage.\\
\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{figs/Hexagonal_Partitioning_Graphic}
\caption{Simulation showing coverage of hexagonal partitions with back and forth motions with three robots. \cite{Azpurua2018}}
\label{fig:Hex}
\end{figure}
\subsection{Voronoi Partitioning}
\label{sec:LR-Voronoi}
% Polygons
In the mathematics field, there are methods of area division to divide a polygon into a number of equal area polygons \cite{Nandakumar2012}. Another relevant method that also stems from the field of mathematics, is the Voronoi partition. This assigns regions within an area to seeds based on distance. The idea is that a region assigned to a seed represents all the points where the distance to that seed is shorter than to any other seed.\\
% Voronoi
% TODO: EDITING - Euclidean and Manhattan should always be with a capital letter 
If the Voronoi partition is applied to the \ac{mcpp} problem, the seeds become synonymous with robots. This partition works for any number of robots at any starting positions, but unless they are evenly spaced, the areas will not have equal sizes. Distances in these scenarios are usually Euclidean and the boundaries between areas represent the position where the distances from two seeds are equal.\\ 
The authors of \cite{Nair2020} implement \ac{mcpp} using Voronoi partitions in discrete space with static obstacles. They use square discretisation of the area and compare several different methods. They investigate geodesic-Manhattan-, Manhattan-, geodesic- and Euclidean-distance-based Voronoi partitions. \\
The Euclidean-based technique results in what the authors term "non-contiguous sub-regions". This means that cells that are part of a sub-region are not accessible by the robot assigned to them, due to obstacles within that sub-region. They solve this problem by using geodesic distance. This uses Euclidean measurements, but instead of a straight line distance between two cells, it calculates the distance using a collision free path between the two cells. \\
Another problem arises, due to their use of discrete space. This is that when using Euclidean distances, some cells were partially in two sub-regions instead of fully in one or the other. Their solution is to use Manhattan distances. Ultimately they claim to have solved these problems by using geodesic-Manhattan-based distances to generate the partition. And thus they coined the term \ac{gm}).\\
Figure \ref{fig:Voronoi} shows figures from the paper that show the results of an area division using different distance measures with a Voronoi partition.In both figures the black blocks represent obstacles, the round dots are the robot starting positions and the black lines over the grid represent the partition boundaries. \\
Figure \ref{fig:Voronoi - Euclid} shows the results using Euclidean distances. Here, the grey blocks are areas that would not be covered. This is clearly remedied using the GM-VPC technique in Figure \ref{fig:Voronoi - GM}. They implemented two different versions of \ac{gm}, which utilize respectively an exact and an approximate individual area search technique. They implemented a boustrophedon coverage plan for the exact solution and a spanning tree for the approximate version. Both of these performed better when using geodesic-Manhattan distances.   
\begin{figure}[h!]
\centering
\begin{subfigure}[b]{0.45\textwidth}
\centering
\includegraphics[scale=0.4]{figs/GM_VPC_Euclid}
\caption{Euclidean}
\label{fig:Voronoi - Euclid}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.45\textwidth}
\centering
\includegraphics[scale=0.4]{figs/GM_VPC}
\caption{Geodesic-Manhattan}
\label{fig:Voronoi - GM}
\end{subfigure}
\caption{Figures showing results for the Voronoi partitioning scheme for two different distance measures. \cite{Nair2020}}
\label{fig:Voronoi}
\end{figure}
\subsection{Negotiation Protocol}
\label{sec:Negotiation}
A negotiation or bargaining protocol refers to a process involving task partitioning. In the context of area division for \ac{cpp}, the task represents the area to be divided \cite{Rossi2009}. The authors of \cite{Rossi2009} present a negotiation model based on Rubinstein's alternate-offers protocol, for the purpose of area division. The focus of their implementation was to develop a distributed algorithm capable of considering robot capabilities. This means that the robots wouldn't have to be homogeneous and can have different flight-time capabilities, manoeuvrability, on-board equipment and so forth \cite{Barrientos2011}.\\ 
They implemented their algorithm and found that it can achieve near optimum results. It tries to maximise the size of each robot's subdivision of the area (based on its capabilities), while also minimising sub-area overlap. The algorithm also works to avoid static obstacles or no fly zones that are present in the area. Moreover, they proved that it could be applied in a situation where re-planning may be necessary.\\
% Re-planning is necessary in a scenario when carrying out the plan changes the environment, thereby requireing replanning wiht the new environment scenario
% TODO: Future work - as new information about target becomes available - replan
A more complete implementation of the algorithm including an individual area search technique was also developed and tested \cite{Barrientos2011}. In this implementation they use a wavefront planner for the individual area coverage path generation. This requires discretisation of the area into cells. In their case, they used rectangles whose size was determined by on-board camera \ac{fov}. In order for the polygons generated by the negotiation protocol to work effectively, they use a method called Bresenham's line algorithm to approximate the lines that divide the areas in discrete space, so that they pass through the centroids of cells.\\
The area division achieved sometimes produces non-convex shapes, which the wavefront planner can handle effectively. Their implementation also minimizes energy consumption by minimizing the number of turns and not allowing backtracking. They also have the ability to specify the initial take-off positions of the robots. Distance from the specified take-off point to the starting point for sub-area coverage are considered in the sub-task negotiations. The authors also mention being able to specify robot landing positions pre-emptively.\\
One visible drawback in their implementation is that they coverage appears incomplete. The boundaries between areas pass through waypoints (cell centroids), that effectively get excluded from the coverage algorithm and are not covered. Using an exact method to search the individual areas could produce better results. Changing the boundaries to lie on the edges of cells rather than passing through their centroids could also make a difference.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{figs/Negotiation_Protocol}
\caption{Figure showing the resulting area partition using the negotiation protocol. This example is for two robots and includes a no fly zone. \cite{Rossi2009}}
\label{fig:NegProt}
\end{figure}
\subsection{MSTC}
\label{sec:LR-MSTC}
\ac{mstc} is a variant of single robot \ac{stc} as presented in Section \ref{sec: LR - sSTC}. The authors of \cite{Hazon2005} designed the first variants of \ac{mstc}. The two variations they suggest are one that allows for backtracking and one that does not. Both variations still utilize a single spanning tree, but simply circumnavigate the tree with multiple robots instead of a single one.\\
They place a lot of emphasis on robustness and efficiency, in addition to completeness. They demonstrate an algorithm that segments the path around a spanning tree to evenly distribute it among robots. This distribution of robots is however, unrealistic. Their method becomes incredibly inefficient when robots are clustered closely together. This is because a robot simply navigates the path until it reaches the initial position of the next robot on the path.\\
Figure \ref{fig:MSTC} shows the paths that are generated when the robots are evenly distributed along the path that circumnavigates the tree. Blue dots represent the robot initial positions and the spanning tree is shown in red. The second method they suggest remedies this somewhat. It allows for backtracking and improves the efficiency.\\
The ideal situation is that all the robots have near equal path lengths, provided they are homogeneous robots. This is not guaranteed with this algorithm when the robots have random starting positions, but allowing for backtracking can improve the results and allow the coverage to be completed in a shorter amount of time.\\
\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{figs/MSTC-Graphic}
\caption{MSTC algorithm showing the paths for three robots on an environment grid. \cite{Hazon2005}}
\label{fig:MSTC}
\end{figure}

\subsection{DARP}
\label{sec:LR DARP}
\section{Non-Distributed Offline MCPP}
\label{sec:LR Non-Distributed MCPP}
This section covers methods that cannot be classified as distributed because the \acp{uav} would likely cross each others paths. The area is not divided into sub-regions as part of the planning process. These are not the type of methods that will be applied in this research paper and is therefore covered in less detail than the distributed case. The different subsections cover different techniques, as with previous sections. Interesting to note is that these methods generally build on single robot coverage techniques like those mentioned in Section \ref{sec:LR sCPP}.
\subsection{MCPP Using MFC}
% insert MFC
\ac{mfc} is a method that was developed by the authors in \cite{Zheng2005} to improve upon the \ac{mstc} method mentioned in Section \ref{sec:LR-MSTC}. Their intent was to construct a tree with the consideration that it will be divided afterwards, unlike what \ac{mstc} does. It allows for robot path overlap, which means there is redundant coverage and collision avoidance would need to be considered. However it can handle unique scenarios, where backtracking is unavoidable, quite well.\\ 
Their implementation is based on an algorithm presented in \cite{Even2003}. This is an approximation algorithm and they specifically looked at the rooted tree cover scenario. The roots represent the robot initial positions and then a tree is generated for each robot, using the objective to minimize the weight of the maximum weight tree. These trees are each circumnavigated by their robot (root) to cover the area.\\
Based on the simulations they ran with \ac{mstc} and \ac{mfc}, they found that \ac{mfc} generated closer to optimum results and generally achieved coverage in a shorter amount of time.	Because there is path overlap in certain scenarios, \ac{mfc} is not a truly distributed method. Results generated by this algorithm can resemble a distributed algorithm quite closely, depending on the environment.
\subsection{MCPP Using Artificial Intelligence}
\label{sec:LR-mAI}
\acl{ai} based methods have already been mentioned in Section \ref{sec:LR - sAI}. In this same paper, the application was extended to the multiple robot scenario \cite{Juan2018}. They investigate the distributed case, however they don't present their method for dividing the environment into subregions. They also investigate the free formation case for the two and three \ac{uav} scenario, and this is of more interest for the purpose of this literature review.

Free formation means that the paths for multiple \acp{uav} are planned in tandem. This means that their paths will potentially cross, implying that collision avoidance would need consideration. Distributed methods explicitly divide an area into sub-regions to be searched by individual \acp{uav}. They will never cross each other's paths, and collision avoidance is not a consideration. This paper does not address collision avoidance in the free formation case. It simply allows the paths to cross.

Three of the methods mentioned in Section \ref{sec:LR - sAI} are tested for distributed and free formation flying. \ac{pso} was not considered because it performed poorly in the single robot case. In general they found that the La Palma attraction method produces the shortest paths. The \ac{anfis} method comes in close second, and the fuzzy logic approach produces significantly longer paths. Therefore, if coverage time minimisation is important, then the attraction method performs the best.

It should be mentioned that they implemented an occupancy grid, which they generate once. This encourages the algorithms to visit certain regions of the map first. Their performance in this regard may influence one's decision to choose one algorithm over another. This will be discussed further in \ref{sec:LR-SAR-AI}, as it becomes more relevant in its particular application to \ac{sar}.
\subsection{MCPP Using Linear Programming}
Linear programming can be used to optimize linear problems with a number of variables, by trying to minimise or maximise some cost. They are also usually subject to several constraints. This methodology has been adapted to an application with multiple \acp{uav} for \ac{cpp}. \cite{Avellar2015}

The authors of this paper designed their optimization problem with the main objective of minimising coverage time. Their algorithm does this by minimising the length of the longest \ac{uav} flight path. 

One contribution they provide is the consideration of setup time. By their definition, setup time refers to the time taken by an operator to prepare a \ac{uav} for flight. They specifically consider scenarios where setup times can accumulate due to there being less operators than \acp{uav}, which leads to an accumulation of setup time for some \acp{uav}.

They apply several constraints to the problem. They limit the flight times of \acp{uav} based on battery power, set a constraint so that every node can be visited by only one \ac{uav} and limit the paths to closed-loop paths so they will always end their paths where they started. 

To ensure complete coverage they develop a constraint that ensures all nodes in one row are visited by one \ac{uav}. They also have two optional constraints to avoid diagonal lines that cross the environment. Obstacles are not considered in their implementation nor are \ac{uav} collisions. In some cases, their implementations resemble the results of a distributed case, but in some cases the algorithm still causes paths to cross.
\section{Online MCPP}
\label{sec:LR Online MCPP}
Online path planning generally refers to scenarios where a plan is generated while information about the environment is still being collected. This is often applicable in highly dynamic environments, where obstacle positions are difficult (or costly) to predict a priori. This type of planning will not be used in this project, as the environment is mapped out a priori and is not considered to by dynamic. Therefore, online planning will only be discussed briefly.

Some of the single robot coverage algorithms of Section \ref{sec:LR sCPP} have online versions. One example uses boustrophedon-A*, where the boustrophedon regions of an environment are constructed incrementally and A* is used to move from one region to the next for coverage\cite{Viet2012}. \ac{stc} can also be done online, by growing the tree incrementally \cite{Gabriely2001}. 

Sampling-based methods are well suited to online approaches. Single query approaches like \ac{rrt} avoid explicit representation of the environment and can therefore be used in dynamic environments more easily \cite{Lavalle2006}.

Often algorithms also use a hybrid of online and offline, where some information about the environment is known a priori, but data is still collected to update certain aspects of the environment incrementally. Often, because of the online element in the algorithm, overall it is still considered as an online approach. 

The paths of the \acp{uav} are generally created dynamically for online path planning, and because all the environment information cannot be known a priori, it is not possible to guarantee complete coverage.

When it comes to online \ac{cpp} with multiple robots, there are a few examples. One such example is a plan for multiple cleaning robots \cite{Luo2002}. This application implements a neural network to plan paths for multiple robots in a dynamic environment. No learning procedures were executed for this algorithm. 

The robots treat each other as dynamic obstacles within an environment and are at all times aware of the other robot positions relative to themselves. The goal is also to minimise rotations and avoid collisions with other obstacles and robots in the environment, while also covering the whole area. 

In their paper they show that the algorithm works effectively in a warehouse environment with ground vehicles, and gives real-time performance. The robots cover the entire area while avoiding collisions with each other and obstacles, and without ever crossing paths or backtracking.

An online application with multiple \acp{uav}, intended for \acl{sar} operations, was also developed. This implementation is discussed in detail in Section \ref{sec:LR SAR Decision Theory} \cite{WaharteFINAL2010}. Their algorithm iteratively updates an occupancy grid of the environment. This represents the likelihood of the target being in any given grid cell, based on the information collected. 

This information is used by each \ac{uav} to choose its next action using a steepest gradient method. This approach can arguable be considered to favour target finding over achieving coverage, but the result is similar to that of a coverage algorithm. 

Section \ref{sec:LR SAR QoS} describes another online algorithm. Here, \acs{ga} are used to optimize coverage and communication with multiple \acs{uav} in a \ac{sar} operation. Connectivity to the ground station can be prioritised to ensure new information about the target can reach the ground station efficiently. This information can be used for dynamic replanning of \ac{uav} paths. \cite{Hayat2020}

\section{UAVs and Search and Rescue}
This section covers several applications where \acp{uav} were used in \ac{sar} scenarios. These examples are not limited to the coverage scenario, and are also not limited to applications with multiple \acp{uav}. Both online and offline approaches are also mentioned. The headings in this section are designed to show the unique attributes of each implementation, which are emphasised by the respective authors in their work and add to the value of their work.
\subsection{Complete Implementation by DroneSAR}
\subsection{Artificial Intelligence Based Approaches with Multiple UAVs}
\label{sec:LR-SAR-AI}
This method has been covered in Section \ref{sec:LR - sAI} for its application in the single robot case. It has also been addressed for multiple robots in Section \ref{sec:LR-mAI}. It should be noted that this paper was specifically developed to investigate these methods for \acl{sar} applications \cite{Juan2018}.

They developed an risk/occupancy grid for this purpose. Within the environment grid, the generate a risk/occupancy value ($P$) for each cell. The term is generated by using three different contributions.

The first of these contributions is the terrain factor ($P_{Terrain}$). This is calculated by assessing the likelihood that someone would stay within an area or enter an area and the level of danger they would be in within those areas. This factor has the biggest contribution to the final $P$-value. There is also an emergency factor ($P_{emergency}$) which represents emergency situations such as fires within an area. Lastly, there is a historical factor ($P_{historical}$) that assesses the likelihood of a historical event occurring again. This is a binary variably.

Using the $P$-values for all the cells, an risk/occupancy grid is produced that causes the algorithms to favour visiting certain cells first. This grid is not updated recursively. It is only calculated once. In Section \ref{sec:LR-mAI}, three methods are discussed and it is mentioned that the La Palma attraction approach produces the shortest times.

In a search and rescue operation, short distances are favourable because it reduces time to complete coverage. This means that a target will likely be found faster. However, this paper also has a performance measured called weight. This evaluates the algorithms' abilities to visit high $P$-value cells first. These are cells that have a high likelihood of containing the target or are high risk zones for the target to be in.

The fuzzy logic approach was found to have the lowest weights of the three methods. However, this is by such a small margin that in the end the \ac{anfis} approach seems to give the best overall performance. It has much shorter distances than the fuzzy logic approach and lower weights than the attraction approach. Therefore, the authors concluded that this approach works best for \ac{sar} in both the distributed and free formation case. 
\subsection{Online Approach with Multiple UAVs and Changing Altitudes}
\label{sec:LR SAR Decision Theory}
Several works by the same group of authors were presented regarding the use of \acp{uav} for \acl{sar} in the years 2009 and 2010. The authors published their preliminary work regarding coordinated search operations with multiple \acp{uav} \cite{Waharte2009}. 

Their setup uses quad rotors searching for a single target in a two dimensional environment. They utilise a downward facing camera as the sensing device for target detection and onboard GPS for localisation. The environment is divided into a grid and each cell is assigned a probability. This probabilistic map represents a likelihood of the target lying within each cell and forms what is called an \emph{occupancy grid}.

Updating the occupancy grid is done using a recursive Bayesian technique. The assumption of a stationary target means that all the cells are updated for every observation. The occupancy grids are calculated locally on each \ac{uav} and are only communicated to others when in communication range. This is referred to as a decoupled approach. 

Deciding on a next cell to visit is done by applying a steepest gradient method to the occupancy grid. Their simulation results show that using multiple \acp{uav}, that share information, significantly decreases the time to find the target.

In a separate paper, also by theses authors, they build on their model by including the ability to have multiple observations for one cell and account for changing altitudes of \acp{uav} \cite{Waharte2010}. Another paper addresses the actual target detection algorithm \cite{Symington2010}.

For target detection, they once again use a Bayesian estimator and evaluate the probability of target detection at changing altitudes using video data. They found that the sampling rate should be chosen according to the application. For search and rescue it should be chosen so as to minimise false negatives.

Ultimately they conclude that changing altitudes can speed up the search process. They went on to test this strategy online with three different approaches, specifically for \acl{sar} applications. The approaches were designed to deal with information sharing limitations, collision avoidance and uncertainties in the sensor data. The approach that gave the fastest target detection was the Partially Observable Markov Decision Process. \cite{WaharteFINAL2010} 

\subsection{Online Approach with One UAV and Human Detection Algorithm}
\label{sec:LR SAR-Sampling}
% Sampling-Based Methods
Sampling-based methods are good for dynamic applications. Path planning algorithms such as \ac{prm} and \ac{rrt} are well suited to online, or partially online applications. These two methods were incorporated into a single path planner as part of a navigation framework by the authors of \cite{Wzorek2006}. They also implemented dynamic replanning to account for unforeseen changes in the system. 

This can be seen as an essentially online planning algorithm because it is reactive within the environment, which is not assumed to be known in full a priori. This can be regarded as a point-to-point path planner. The navigation is is extended to \ac{cpp} in a later paper intended to be used for \ac{sar} \cite{Rudol2008}. They used their sampling-based navigation to execute back and forth motions over an area with an unmanned helicopter. The back and forth manoeuvres can be seen as a series of point-to-point navigations. 

In this paper, the main focus was however, human body detection. They collect video using a \ac{uav} with both visual and thermal cameras on-board. The footage is analysed online using an algorithm for human detection. The lower resolution thermal imagery is used to find locations of potential humans, and then higher resolution visual data is then analysed to confirm. 

According to their results, the algorithm detects humans at a rate of 25Hz. It occasionally produces false positives, but this is generally preferred over failed detections. A failure to detect a target in \acl{sar} would be catastrophic. 

%\subsection{SAR with a Moving Target}
\subsection{Multiple UAV Approach with Quality of Service Requirements}
\label{sec:LR SAR QoS}
The focus of the work by these authors is communication. A lot of emphasis was placed on getting information back to the ground station timeously. They developed a \ac{mopp} algorithm that can be tuned to favour connectivity, coverage or both in varying degrees. \cite{Hayat2020}

Coverage is important for target detection, and this is the initial goal of their algorithm. However, once a target is located, good connectivity is important to get relevant information back to the ground station as fast as possible.

Connectivity, according to the authors, is broken down into two tasks. The first task involves transmitting the location of a target back to the ground station once located. The second task is continuous monitoring of the target via a good \ac{qos} link. This sends real-time updates on the target to the ground crew.

A \acf{ga} is used to optimize the overall mission time, which includes searching the area for the target, sending the target location back to the ground crew, and establishing a good link to the ground station for continuous updates on the target. The paths found by this algorithm can be updated dynamically as new information about the target is received.

This method can be viewed as decentralized technique, because the assumption is that the \acp{uav} are not always within communication range of one another. The connectivity phase of their algorithm is used to relay information between \acp{uav} back to the ground station, which generally requires planning paths to reconfigure them for optimal connectivity. If, once the target it located, the \ac{uav} that found the target is within range of the ground station, the connectivity phase is not required.

It is interesting to see the value of incorporating connectivity as a mission goal. Their algorithms were shown to have faster mission completion times than similar algorithms that use connectivity as a constraint instead of a goal. Their results also show that favouring connectivity gives better results for a small group of \acp{uav} and favouring coverage gives better results for a larger group.

